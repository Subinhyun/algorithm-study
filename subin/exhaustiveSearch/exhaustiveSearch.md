## 완전탐색

완전탐색 : 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법

우선 완전탐색 기법으로 문제를 풀기 위해서는 다음과 같이 고려해서 수행한다.

1) 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산한다.
2) 가능한 모든 방법을 다 고려한다.
3) 실제 답을 구할 수 있는지 적용한다.

</br> 

여기서 2)의 모든 방법에는 다음과 같은 방법 등이 있다.

① Brute Force 기법 - 반복 / 조건문을 활용해 모두 테스트하는 방법

② 순열(Permutation) - n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법

③ 재귀 호출

④ 비트마스크 - 2진수 표현 기법을 활용하는 방법

⑤ BFS, DFS를 활용하는 방법

</br>

① Brute Force 기법

이 방법은 반복 / 조건문을 통해 가능한 모든 방법을 단순히 찾는 경우를 의미한다. 예를 들어, 위의 자물쇠 암호를 찾는 경우와 같이 모든 경우를 다 참조하는 경우가 그러하다.

② 순열(Permutation)
순열 : 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미

즉, 순서가 중요! 만약, 수열에서 숫자 [1, 2, 3]이 있다면, 이것을 [1, 2, 3]으로 보는 순서와 [3, 2, 1]로 보는 순서가 차이가 있음이 중요한 경우를 의미

같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전 / 다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.

③ 재귀(Recursive)

재귀 : 말 그대로 자기 자신을 호출하는 것

여기서 중요한 점!

⑴ 재귀를 탈출하기 위한 탈출 조건이 필요!

  ▶ 이것이 없으면 n개를 모두 골랐음에도 더 숫자를 선택하고자 하여 선택된 숫자를 저장하는 배열에 범위 초과 오류가 나거나, 다른 자료구조를 쓴 경우 잘못된 출력이 나올 수 있고, 혹은 무한 루프가 발생할 수 있다!

⑵ 현재 함수의 상태를 저장하는 Parameter가 필요!

  ▶ 위에서 우리는 curr, cnt를 통해 어떤 숫자까지 선택했는지, 몇 개를 선택했는지 전달하였다. 이것이 없다면 현재 함수의 상태를 저장할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력하게 된다!

⑶ Return문을 신경 쓸 것!

  ▶ 위의 함수는 단순 출력이기에 void로 함수를 작성했다. 그런데, 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우도 있을 수 있다. 즉, 문제 해결을 위한 정확한 정의를 수행하여야 이것을 완벽히 풀 수 있다.


④ 비트마스크(Bitmask)

비트마스크란 비트(bit) 연산을 통해서 부분 집합을 표현하는 방법을 의미한다.

비트 연산
- And 연산(&) : 둘 다 1이면 1
- OR 연산(|) : 둘 중 1개만 1이면 1
- NOT 연산(~) : 1이면 0, 0이면 1
- XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0
- Shift 연산(<<, >>) : A << B라고 한다면 A를 좌측으로 B 비트만큼 미는 것

⑤ BFS, DFS를 활용하는 방법

</br>

---

